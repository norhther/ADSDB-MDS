import time
import duckdb
import pathlib
import random
from pandas_profiling import ProfileReport
from datetime import datetime
import logging

logger = logging.getLogger("Exploitation logger")
c_handler = logging.StreamHandler()
c_handler.setFormatter(logging.Formatter(fmt=' %(name)s :: %(levelname)-8s :: %(message)s'))
logger.addHandler(c_handler)
logger.setLevel(logging.DEBUG)

def data_quality(df, name):
    logger.info("Data quality report for " + name)
    profile = ProfileReport(df, title="Profiling Report")
    now = datetime.now().strftime("%m-%d-%Y-%H-%M-%S") 
    profile.to_file(str(pathlib.Path().resolve().parent) + "/scripts/exploitation/" + str(now) + "@" + name + ".html")
    logger.info("Data quality report saved in " + str(pathlib.Path().resolve().parent) + "/scripts/exploitation/" + str(now) + "@" + name + ".html")


def run():
    sleeping_time = 60
    while True:
        offset = random.randint(0, 9)
        try:
            logger.info("Trying to adquire the db lock...")
            conn_expl = duckdb.connect(database=str(pathlib.Path().resolve().parent) + '/scripts/exploitation/my-db.duckdb', read_only=False)
            conn_trusted = duckdb.connect(database=str(pathlib.Path().resolve().parent) + '/scripts/trusted/my-db.duckdb', read_only=False)
            trusted_cursor = conn_trusted.cursor()
            logger.info("Lock adquired!")
            # merge tables
            logger.info("Checking for joining tables")
            df = trusted_cursor.execute("SELECT * FROM student INNER JOIN countrycode on student.country = countrycode.country INNER JOIN IQ on countrycode.country_name = IQ.country").df()
            conn_expl.execute(f"CREATE OR REPLACE TABLE dataset AS SELECT * FROM df")
            logger.info("Tables joined")
            data_quality(df, "dataframe")

        except BaseException as error:
            print(error)
            logger.warning("Can't lock the db or no new data. Retrying shortly...")

            
        finally:
            conn_expl.close()
            conn_trusted.close()
            time.sleep(sleeping_time + offset)
            logger.info("Lock released")
